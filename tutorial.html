<!DOCTYPE html>
<html>
<head>
    <title>Left or Right</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="../libraries/three.js-r87/build/three.min.js"></script>
<script src="../libraries/three.js-r87/src/helpers/AxisHelper.js"> </script>
<script src="../libraries/three.js-r87/examples/js/libs/stats.min.js"></script>
<script src="../libraries/three.js-r87/examples/js/controls/OrbitControls.js"></script>

<script>
    var Camera, Scene, Renderer, Container, Stats, AxisHelper, 
        Mouse = new THREE.Vector2(), Vector0 = new THREE.Vector3(0,0,0);
    var n= 100, camera_position ={
            x: 0    ,
            y: n/2,
            z: n/2
        }, c_c ={
            x: 1,
            y: 1,
            z: 1
        }, f_c = {
            x: n*c_c.x/2,
            y: c_c.y/2  ,
            z: n
        }, b_c = {
            x: c_c.x/2,
            y: c_c.y,
            z: n
        }, center = 0, move_cubes = 0, baffle_status = 0, move_baffle = 0, animate_speed = f_c.x/200,
        rotate_speed = Math.PI / 720, fall_speed = c_c.x/20, angle = 0, status_field = null, overweight = 0,
        on_edge = 0, start_round = false, draw = false;

    //Массив кубов, поле
    var Cubes = [], MoveCubes = [], StatusCubes = [], Field, Baffle;

    init();
    animate();

    function init() {

        Container = document.createElement( 'div' );
        document.body.appendChild( Container );

        Camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
        Camera.position.set(camera_position.x, camera_position.y, camera_position.z);
        Camera.lookAt(Vector0);
        Controls = new THREE.OrbitControls( Camera );

        Scene = new THREE.Scene();
        Scene.background = new THREE.Color( 0xf0f0f0 );
        AxisHelper = new THREE.AxisHelper( 5 );
        Scene.add( AxisHelper );
        var Light = new THREE.DirectionalLight( 0xffffff  , 1 );
        Light.position.set( 1, 1, 1 ).normalize();
        Scene.add( Light );

        var Colors = [ new THREE.Color(0xF4C430),
            new THREE.Color(0xC8A2C8),
            new THREE.Color(0x007FFF),
            new THREE.Color(0x3B005C),
            new THREE.Color(0x00A86B),
            new THREE.Color(0xDC143C)];
        var BaffleGeometry = new THREE.BoxGeometry( b_c.x, b_c.y, b_c.z );
        var BaffleMaterial = new THREE.MeshBasicMaterial( {color: 0x00ffff, side: THREE.DoubleSide} );
        Baffle = new THREE.Mesh( BaffleGeometry, BaffleMaterial );
        Baffle.position.y +=b_c.y/2+c_c.y;
        var FieldGeometry = new THREE.BoxGeometry( f_c.x, f_c.y, f_c.z );
        var FieldMaterial = new THREE.MeshBasicMaterial( {color: 0xff00ff, side: THREE.DoubleSide} );
        Field = new THREE.Mesh( FieldGeometry, FieldMaterial );
        Field.position.y -=f_c.y/2;
        Scene.add( Field );
        Scene.add( Baffle );
        for (var i=0; i<n; i++) {
            Cubes.push(new THREE.Mesh(new THREE.BoxGeometry( c_c.x, c_c.y, c_c.z ),
                new THREE.MeshLambertMaterial( { color: Colors[i%6] } )));
            Cubes[i].position.z = -n/2 + i + c_c.z/2 ;
            Cubes[i].position.y += c_c.y/2;
            var way = Math.random();
            if (way < 0.5) way = -1;
                else way =1;
            MoveCubes.push(way);
            StatusCubes.push(0);
            Scene.add(Cubes[i]);
        }

        Renderer = new THREE.WebGLRenderer({antialias: true});
        Renderer.setSize( window.innerWidth, window.innerHeight );
        Renderer.setPixelRatio( window.devicePixelRatio );
        Container.appendChild( Renderer.domElement );

        Stats = new Stats();
        Container.appendChild( Stats.dom);

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );

        window.addEventListener( 'resize', onWindowResize, false );

        window.addEventListener( 'keydown', onWindowKeyDown, false );
    }

    function onWindowResize() {
        Camera.aspect = window.innerWidth / window.innerHeight;
        Camera.updateProjectionMatrix();
        Renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function onWindowKeyDown( event ) {
        event.preventDefault();
        if (event.keyCode == 82)//r
        {
            start_round = true;
        }
        if (event.keyCode == 81)//q
        {
            move_cubes = -1;
        }
        if (event.keyCode == 32)//space
        {
            move_cubes = 0;
        }
        if (event.keyCode == 69)//e
        {
            move_cubes = 1;
        }
        if (event.keyCode == 87)//w
        {
            if (center!=0)
                move_baffle = 1;
        }
        if (event.keyCode == 83)//s
        {
            if (center!=0)
                move_baffle = -1;
        }
        if (event.keyCode == 65)//a
        {
            if (baffle_status==-1)
                move_baffle = -1;
        }
        if (event.keyCode == 68)//d
        {
            if (center!=0)
                move_baffle = -1;
        }
    }

    function onDocumentMouseMove( event ) {
        event.preventDefault();
        Mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        Mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
        Stats.update();
        Controls.update();
    }
    
    function render() {
        //начало раунда
        if (start_round &&  overweight  == 0 && !draw)
        {
            for (var i=0; i<n; i++) {
                if (Cubes[i].position.x - c_c.x / 2 - animate_speed <= -f_c.x / 2 ||
                    Cubes[i].position.x + c_c.x / 2 + animate_speed >= f_c.x / 2)
                    StatusCubes[i] = MoveCubes[i];
                if (StatusCubes[i] == 0)
                    Cubes[i].position.x += MoveCubes[i] * animate_speed;
                else overweight += StatusCubes[i];                
            }
            //проверка на равномерное разделение
            if  (StatusCubes[0] != 0 && overweight == 0)
                draw = true;
            if (overweight > 0) 
                status_field = 1;
            else 
                status_field = -1;   
        }
        if (baffle_status==-1){
            //отступ от края            
            if (on_edge < c_c.x/2)
                    on_edge += animate_speed;
            else 
                for (var i=0; i<n; i++)                  
                    if (status_field == StatusCubes[i])                  
                        StatusCubes[i] += status_field;
            //поворот поля
            if (Math.abs(angle / rotate_speed)  <= 100){
                angle -= rotate_speed*status_field;
                Scene.rotation.z = angle;                                 
            }
            for (var i=0; i<n; i++){
                if (1 == Math.abs(StatusCubes[i]))                    
                        Cubes[i].position.x += status_field * animate_speed;                
                //движение меньшества  
                if (Cubes[i].position.x - c_c.x / 2  <= b_c.x / 2 &&
                    Cubes[i].position.x + c_c.x / 2  >= -b_c.x / 2)
                    StatusCubes[i] -= status_field;
                //падение большинства
                if (2 * status_field == StatusCubes[i])           
                    {                 
                        j=+2*fall_speed;
                        Cubes[i].rotation.z += -status_field * rotate_speed * 5;
                        Cubes[i].position.x += status_field * j;  
                        Cubes[i].position.y += -2 * (Math.exp(j)- Math.exp(j-fall_speed));                
                    }
            }   
        }                       
    
        //движение всех кубов
        if (move_cubes < 0 && center != -1 )
            for (var i=0; i<n; i++) {
                Cubes[i].position.x -= animate_speed;
                if (Cubes[i].position.x - c_c.x/2 < -f_c.x/2)
                    center = -1;
            }
        if (move_cubes > 0 && center != 1 )
            for (var i=0; i<n; i++) {
                Cubes[i].position.x += animate_speed;
                if (Cubes[i].position.x + c_c.x / 2 > f_c.x / 2)
                    center = 1;
            }
        //движение перегордки
        if (center != 0 || overweight  != 0)
            move_baffle = -1;
        if (move_baffle == -1 && baffle_status != -1)
            Baffle.position.y -= animate_speed;
        if (Baffle.position.y - b_c.y/2 < f_c.y/2 + Field.position.y)
            baffle_status = -1;
        Renderer.render( Scene, Camera );            
    }
</script>
</body>